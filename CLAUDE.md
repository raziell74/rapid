# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## What This Is

R.A.P.I.D. is a Skyrim SE/AE SKSE plugin that hooks into `BSResource::LooseFileLocation` directory traversal to replace the engine's slow `FindFirstFile`/`FindNextFile` enumeration with a pre-built binary cache generated by a companion MO2 Python plugin. The result is near-instant loose file registration at boot, bypassing both the OS file enumeration APIs and MO2's USVFS proxy overhead entirely.

## Creation Engine: Loose File Loading (Context)

In the Creation Engine (Skyrim/Fallout 4), the `BSResource` system acts as a virtual file system (VFS) that abstracts where data comes from (loose files on disk, compressed BSA archives, or even memory-mapped streams).

During the initial load, `RE::BSResource::LooseFileLocation` and `RE::BSResource::LocationTraverser` are key components in the **Resource Authority** and **Mounting** phase.

### 1. RE::BSResource::LooseFileLocation

This class is a concrete implementation of the `RE::BSResource::Location` interface. It represents a physical directory on your drive—most commonly the `Data/` folder.

* **Responsibility**: Its primary job is to handle "unpacked" files. It maps a virtual path (e.g., `textures/actors/human/face.dds`) to a physical path on the OS (e.g., `C:\Games\Skyrim\Data\textures\actors\human\face.dds`).
* **Initialization**: During startup, the engine creates a "Global" `LooseFileLocation` instance pointing to the `Data` directory.
* **The "Loose File Always Wins" Rule**: In the engine's internal priority list, the `LooseFileLocation` is typically checked *after* BSAs in the mount order, but because of how the traverser works (see below), if a file exists here, it is usually flagged to override archive entries.

### 2. RE::BSResource::LocationTraverser

The `LocationTraverser` is a "visitor" pattern implementation used to iterate through all mounted locations (archives and folders) to find a specific resource or list all resources in a directory.

* **The Search Process**: When the game needs to load a mesh or texture, it doesn't just check one folder. It asks the `EntryDB` or `FileSystem` to "traverse" the mounted locations.
* **Initial Load Behavior**:
1. **Mounting**: On startup, the engine reads the `SResourceArchiveList` from `Skyrim.ini`. It creates `ArchiveLocation` objects for each BSA and a `LooseFileLocation` for the Data folder.
2. **Iterative Discovery**: The `LocationTraverser` walks through these locations in a specific order. For every virtual path requested, the traverser visits each `Location`.
3. **Prioritization**:
* Inside the traverser's `Process` method, it checks if the current `Location` (like a `LooseFileLocation`) contains the requested file.
* If it finds a match in a `LooseFileLocation`, it usually marks that as the "authoritative" version. This is why loose files override BSAs—the engine is designed to let the traverser prefer the "Loose" implementation if it returns a valid stream.

### What happens during Initial Load?

1. **System Setup**: `RE::BSResource::FileSystem` initializes the singleton. It creates the root mount points.
2. **Mounting the Data Folder**: A `LooseFileLocation` is instantiated for the `Data` directory. This is the first "Location" that represents the raw disk.
3. **Traversing for Configs**: Even before the main menu, the engine uses a `LocationTraverser` to find initial configuration files and core shaders.
4. **The "Loose" Check**: Every time the traverser hits a `LooseFileLocation`, it performs a low-level OS call (like `GetFileAttributesExW`) to see if the file exists on disk.
* *Performance Note:* This is why having thousands of loose files is slower than BSAs. The `LocationTraverser` has to wait for the OS to check the disk for every single asset request, whereas for BSAs, it just checks an in-memory index of the archive's header.

### Summary for CommonLibSSE-NG Users

RE types, API details, and engine bindings come from [CommonLibSSE-NG](https://github.com/CharmedBaryon/CommonLibSSE-NG). If you are looking at this via **CommonLibSSE-NG**, you are likely seeing these in **Crash Logs** or trying to **Hook** them:

* **In Crash Logs**: A crash in `LooseFileLocation` usually means the engine found a file on disk but failed to open a stream to it (permissions, file corruption, or "Too many open files" limit).
* **For Plugin Devs**: You can theoretically create your own `Location` (by inheriting from `BSResource::Location`) and inject it into the `FileSystem` via a `LocationTraverser` to provide your own virtual files that don't exist on disk or in a BSA.

## Build

Requires MSVC, CMake 3.21+, and vcpkg with `VCPKG_ROOT` set. Dependencies are sourced from a custom registry (`Monitor221hz/modding-vcpkg-ports`) for `commonlibsse-ng-fork` (upstream: [CommonLibSSE-NG](https://github.com/CharmedBaryon/CommonLibSSE-NG)).

```bash
# Configure
cmake --preset build-debug-msvc

# Build
cmake --build --preset debug-msvc
```

Output goes to `build/release-msvc/` or `build/debug-msvc/`. If `SKYRIM_MODS_FOLDER` is set, the compiled `.dll` is automatically copied to `$SKYRIM_MODS_FOLDER/RAPID - Resource Asset Path Indexing and Dispatch/SKSE/Plugins/`.

## Architecture

The plugin is early-stage. The two core files that will house the actual implementation are currently stubs:

- `src/hook.h` / `src/hook.cpp` — where the `BSResource::LooseFileLocation` trampoline hook lives (currently empty)
- `src/settings.h` — INI-based configuration (currently empty)

The scaffolding that is in place:

- `src/plugin.cpp` — SKSE plugin entry point; calls `SKSE::Init`, sets up logging, and registers the message listener
- `src/log.h` — `SetupLog()` wires spdlog to `%SKSE_LOG_DIR%/<PluginName>.log` at trace level
- `src/PCH.h` — precompiled header; pulls in `RE/Skyrim.h` and `SKSE/SKSE.h`
- `src/util.h` — utility namespaces: `PointerUtil`, `SystemUtil::File`, `KeyUtil`, `Util::String`, `MathUtil`, `ObjectUtil`, `FormUtil`, `NifUtil`, `AnimUtil`

## MO2 Python Plugin

- `MO2 Plugin/RAPID.py` — companion MO2 plugin; runs pre-launch, walks `virtualFileTree()` and writes `rapid_vfs_cache.bin` to the active profile folder
- Uses a work-stealing `queue.Queue` + `threading.Thread` model (up to 8 workers) for parallel VFS traversal
- Threading relies on pybind11 releasing the GIL during mobase C++ binding calls; workers operate on disjoint tree nodes (no shared mutable state per node)
- Cache format: zlib-compressed binary — 4-byte LE file count, then per-file: 2-byte LE UTF-8 length + UTF-8 path bytes

## Key Conventions

- C++23 (`cxx_std_23`), MSVC only, x64, dynamic CRT linkage
- `RE::` prefix for Reversed Engine types ([CommonLibSSE-NG](https://github.com/CharmedBaryon/CommonLibSSE-NG)), `SKSE::` for SKSE interfaces
- Address Library offsets via `RELOCATION_ID(se_id, ae_id)` for cross-version compatibility ([Address Library Database](https://github.com/meh321/AddressLibraryDatabase))
- New source files must be added to `cmake/sourcelist.cmake`; new headers to `cmake/headerlist.cmake`
- The custom vcpkg triplet (`x64-windows-skse`) statically links everything except `skse` and `fully-dynamic-game-engine` packages
